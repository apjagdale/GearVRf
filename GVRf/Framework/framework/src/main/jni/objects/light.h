/* Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/***************************************************************************
 * Class containing light source parameters.
 ***************************************************************************/

#ifndef LIGHT_H_
#define LIGHT_H_

#include <map>
#include <memory>
#include <string>

#include "objects/shader_data.h"
#include "engine/renderer/renderer.h"
#include "objects/scene_object.h"
#include "objects/components/shadow_map.h"
#include "util/gvr_jni.h"
#include "engine/renderer/renderer.h"

namespace gvr {
class SceneObject;
class Scene;
class Shader;
class ShadowMap;

//#define DEBUG_LIGHT 1

class Light : public JavaComponent
{
public:

    explicit Light()
    :   JavaComponent(Light::getComponentType()),
        shadowMapIndex_(-1)
    {
    }

    virtual ~Light();

    static long long getComponentType()
    {
        return COMPONENT_TYPE_LIGHT;
    }

    int getByteSize(const char* key) const
    {
        return uniforms().getByteSize(key);
    }

    bool hasUniform(const char* key) const
    {
        return uniforms().hasUniform(key);
    }

    int getNumUniforms() const
    {
        return uniforms().getNumUniforms();
    }

    void forEachUniform(std::function< void(const DataDescriptor::DataEntry&) > func) const
    {
        return uniforms().forEachEntry(func);
    }

    void forEachUniform(std::function< void(DataDescriptor::DataEntry&) > func)
    {
        return uniforms().forEachEntry(func);
    }

    Texture* getTexture(const char* key) const
    {
        return uniforms().getTexture(key);
    }

    void setTexture(const char* key, Texture* texture)
    {
        uniforms().setTexture(key, texture);
    }

    bool  getFloat(const char* name, float& v) const
    {
       return uniforms().getFloat(name, v);
    }

    bool getInt(const char* name, int& v) const
    {
        return uniforms().getInt(name, v);
    }

    bool  setInt(const char* name, int val)
    {
        return uniforms().setInt(name, val);
    }

    bool  setIntVec(const char* name, const int* val, int n)
    {
        return uniforms().setIntVec(name, val, n);
    }

    bool setFloatVec(const char* name, const float* val, int n)
    {
        return uniforms().setFloatVec(name, val, n);
    }

    bool  getFloatVec(const char* name, float* val, int n)
    {
        return uniforms().getFloatVec(name, val, n);
    }

    bool getIntVec(const char* name, int* val, int n)
    {
        return uniforms().getIntVec(name, val, n);
    }

    bool setVec2(const char* name, const glm::vec2& v)
    {
        return uniforms().setVec2(name, v);
    }

    bool getFloat(const char* key, float& val)
    {
        return uniforms().getFloat(key, val);
    }

    void setFloat(const char* key, float value)
    {
        uniforms().setFloat(key, value);
    }

    bool setVec3(const char* key, const glm::vec3& vector)
    {
        return uniforms().setVec3(key, vector);
    }

    bool setVec4(const char* key, const glm::vec4& vector)
    {
        return uniforms().setVec4(key, vector);
    }

    bool getMat4(const char* key, glm::mat4& matrix)
    {
        return uniforms().getMat4(key, matrix);
    }

    bool setMat4(const char* key, const glm::mat4& matrix)
    {
        return uniforms().setMat4(key, matrix);
    }

    bool castShadow()
    {
        return getShadowMap() != nullptr;
    }

    ShadowMap* getShadowMap();

    /**
     * Internal function called at the start of each frame
     * to update the shadow map.
     */
    bool makeShadowMap(Scene* scene, ShaderManager* shader_manager, int texIndex);

    virtual int addToLayout(std::ostream& stream);

    virtual void makeLayout(const std::vector<Light*>& lights, std::string& layout);

    const char* getLightID()
    {
        return lightID_.c_str();
    }

    /**
    * Set the light ID. This is a string that uniquely
    * identifies this light. This ID is generated by
    * GVRScene when the light is attached.
    * {@link GVRScene.addLight }
    */
    void setLightID(const char* lightid)
    {
        lightID_ = lightid;
    }

    virtual void onAddedToScene(Scene* scene);
    virtual void onRemovedFromScene(Scene* scene);
    virtual ShaderData&       uniforms() = 0;
    virtual const ShaderData& uniforms() const = 0;

private:
    Light(const Light& light) = delete;
    Light(Light&& light) = delete;
    Light& operator=(const Light& light) = delete;
    Light& operator=(Light&& light) = delete;

private:
    int shadowMapIndex_;
    std::string lightID_;
};
}
#endif
